// This file is autogenerated.
// Ideally it wouldn't exist, but it's here to test cjs in node
// Changes should go into ./test.js, and if new assertions are needed
// they'll need to be shimmed here as well
const tinycolor = require("./tinycolor.js");
const { Deno, testDefinitions } = require("@deno/shim-deno-test");
async function runDenoTests() {
  for (const test of testDefinitions) {
    if (test.ignore) {
      console.log(`Ignoring ${test.name}`);
      continue;
    }
    console.log(`Running ${test.name}`);
    await test.fn();
    console.log(`> Passed ${test.name}`);
  }
}
(async () => {
  const { assertEquals, assert, assertThrows } = await import(
    "../deno_asserts@0.168.0.mjs"
  );

  // TEST_BEGINS_HERE

Deno.test("TinyColor initialization", function () {
  assert(
    typeof tinycolor != "undefined",
    "tinycolor is initialized on the page"
  );
  assert(
    typeof tinycolor("red") == "object",
    "tinycolor is able to be instantiated"
  );

  var r = tinycolor("red");
  assert(
    tinycolor(r) === r,
    "when given a tinycolor instance, tinycolor() returns it"
  );
  assert(
    new tinycolor(r) === r,
    "when given a tinycolor instance, new tinycolor() returns it"
  );
  assertEquals(
    tinycolor("red", { format: "hex" }).toString(),
    "#ff0000",
    "tinycolor options are being parsed"
  );
  assertEquals(
    tinycolor.fromRatio({ r: 1, g: 0, b: 0 }, { format: "hex" }).toString(),
    "#ff0000",
    "tinycolor options are being parsed"
  );

  var obj = { h: 180, s: 0.5, l: 0.5 };
  var color = tinycolor(obj);
  assert(
    obj.s === 0.5,
    "when given an object, the original object is not modified"
  );
});

Deno.test("Original input", function () {
  var colorRgbUp = "RGB(39, 39, 39)";
  var colorRgbLow = "rgb(39, 39, 39)";
  var colorRgbMix = "RgB(39, 39, 39)";
  var tinycolorObj = tinycolor(colorRgbMix);
  var inputObj = { r: 100, g: 100, b: 100 };
  var r = tinycolor("red");

  assert(
    tinycolor(colorRgbLow).getOriginalInput() === colorRgbLow,
    "original lowercase input is returned"
  );
  assert(
    tinycolor(colorRgbUp).getOriginalInput() === colorRgbUp,
    "original uppercase input is returned"
  );
  assert(
    tinycolor(colorRgbMix).getOriginalInput() === colorRgbMix,
    "original mixed input is returned"
  );
  assert(
    tinycolor(tinycolorObj).getOriginalInput() === colorRgbMix,
    "when given a tinycolor instance, the color string is returned"
  );
  assert(
    tinycolor(inputObj).getOriginalInput() === inputObj,
    "when given an object, the object is returned"
  );
  assert(
    new tinycolor("").getOriginalInput() === "",
    "when given an empty string, an empty string is returned"
  );
  assert(
    new tinycolor(null).getOriginalInput() === "",
    "when given a null value, an empty string is returned"
  );
});

Deno.test("Cloning color", function () {
  var originalColor = tinycolor("red");
  var originalColorRgbString = originalColor.toRgbString();

  var clonedColor = originalColor.clone();
  assert(
    clonedColor.toRgbString() === originalColor.toRgbString(),
    "cloned color is identical"
  );

  clonedColor.setAlpha(0.5);
  assert(
    clonedColor.toRgbString() !== originalColor.toRgbString(),
    "cloned color is changing independently from original color"
  );
  assert(
    originalColorRgbString === originalColor.toRgbString(),
    "original color was not changed by cloned color change"
  );
});
Deno.test("Random color", function () {
  var randomColor = tinycolor.random();
  assertEquals(randomColor.getAlpha(), 1);
  assertEquals(randomColor.getFormat(), "prgb");

  randomColor.setAlpha(0.5);
  assertEquals(randomColor.toHex8String().slice(-2), "80");
});

// Taken from convertWikipediaColors.html
var conversions = [
  {
    hex: "#FFFFFF",
    hex8: "#FFFFFFFF",
    rgb: { r: "100.0%", g: "100.0%", b: "100.0%" },
    hsv: { h: "0", s: "0.000", v: "1.000" },
    hsl: { h: "0", s: "0.000", l: "1.000" },
  },
  {
    hex: "#808080",
    hex8: "#808080FF",
    rgb: { r: "050.0%", g: "050.0%", b: "050.0%" },
    hsv: { h: "0", s: "0.000", v: "0.500" },
    hsl: { h: "0", s: "0.000", l: "0.500" },
  },
  {
    hex: "#000000",
    hex8: "#000000FF",
    rgb: { r: "000.0%", g: "000.0%", b: "000.0%" },
    hsv: { h: "0", s: "0.000", v: "0.000" },
    hsl: { h: "0", s: "0.000", l: "0.000" },
  },
  {
    hex: "#FF0000",
    hex8: "#FF0000FF",
    rgb: { r: "100.0%", g: "000.0%", b: "000.0%" },
    hsv: { h: "0.0", s: "1.000", v: "1.000" },
    hsl: { h: "0.0", s: "1.000", l: "0.500" },
  },
  {
    hex: "#BFBF00",
    hex8: "#BFBF00FF",
    rgb: { r: "075.0%", g: "075.0%", b: "000.0%" },
    hsv: { h: "60.0", s: "1.000", v: "0.750" },
    hsl: { h: "60.0", s: "1.000", l: "0.375" },
  },
  {
    hex: "#008000",
    hex8: "#008000FF",
    rgb: { r: "000.0%", g: "050.0%", b: "000.0%" },
    hsv: { h: "120.0", s: "1.000", v: "0.500" },
    hsl: { h: "120.0", s: "1.000", l: "0.250" },
  },
  {
    hex: "#80FFFF",
    hex8: "#80FFFFFF",
    rgb: { r: "050.0%", g: "100.0%", b: "100.0%" },
    hsv: { h: "180.0", s: "0.500", v: "1.000" },
    hsl: { h: "180.0", s: "1.000", l: "0.750" },
  },
  {
    hex: "#8080FF",
    hex8: "#8080FFFF",
    rgb: { r: "050.0%", g: "050.0%", b: "100.0%" },
    hsv: { h: "240.0", s: "0.500", v: "1.000" },
    hsl: { h: "240.0", s: "1.000", l: "0.750" },
  },
  {
    hex: "#BF40BF",
    hex8: "#BF40BFFF",
    rgb: { r: "075.0%", g: "025.0%", b: "075.0%" },
    hsv: { h: "300.0", s: "0.667", v: "0.750" },
    hsl: { h: "300.0", s: "0.500", l: "0.500" },
  },
  {
    hex: "#A0A424",
    hex8: "#A0A424FF",
    rgb: { r: "062.8%", g: "064.3%", b: "014.2%" },
    hsv: { h: "61.8", s: "0.779", v: "0.643" },
    hsl: { h: "61.8", s: "0.638", l: "0.393" },
  },
  {
    hex: "#1EAC41",
    hex8: "#1EAC41FF",
    rgb: { r: "011.6%", g: "067.5%", b: "025.5%" },
    hsv: { h: "134.9", s: "0.828", v: "0.675" },
    hsl: { h: "134.9", s: "0.707", l: "0.396" },
  },
  {
    hex: "#B430E5",
    hex8: "#B430E5FF",
    rgb: { r: "070.4%", g: "018.7%", b: "089.7%" },
    hsv: { h: "283.7", s: "0.792", v: "0.897" },
    hsl: { h: "283.7", s: "0.775", l: "0.542" },
  },
  {
    hex: "#FEF888",
    hex8: "#FEF888FF",
    rgb: { r: "099.8%", g: "097.4%", b: "053.2%" },
    hsv: { h: "56.9", s: "0.467", v: "0.998" },
    hsl: { h: "56.9", s: "0.991", l: "0.765" },
  },
  {
    hex: "#19CB97",
    hex8: "#19CB97FF",
    rgb: { r: "009.9%", g: "079.5%", b: "059.1%" },
    hsv: { h: "162.4", s: "0.875", v: "0.795" },
    hsl: { h: "162.4", s: "0.779", l: "0.447" },
  },
  {
    hex: "#362698",
    hex8: "#362698FF",
    rgb: { r: "021.1%", g: "014.9%", b: "059.7%" },
    hsv: { h: "248.3", s: "0.750", v: "0.597" },
    hsl: { h: "248.3", s: "0.601", l: "0.373" },
  },
  {
    hex: "#7E7EB8",
    hex8: "#7E7EB8FF",
    rgb: { r: "049.5%", g: "049.3%", b: "072.1%" },
    hsv: { h: "240.5", s: "0.316", v: "0.721" },
    hsl: { h: "240.5", s: "0.290", l: "0.607" },
  },
];

Deno.test("Color Equality", function () {
  for (var i = 0; i < conversions.length; i++) {
    var c = conversions[i];
    var tiny = tinycolor(c.hex);

    assert(true, tiny.isValid());
    assert(
      true,
      "Testing " +
        c.hex +
        ": " +
        tiny.toRgbString() +
        " " +
        tiny.toPercentageRgbString() +
        " " +
        tiny.toHsvString() +
        " " +
        tiny.toHslString() +
        " " +
        tiny.toHexString() +
        "Original: " +
        JSON.stringify(c.rgb) +
        " " +
        JSON.stringify(c.hsv) +
        " " +
        JSON.stringify(c.hsl)
    );
    assert(tinycolor.equals(c.rgb, c.hex), "RGB equals hex " + c.hex);
    assert(tinycolor.equals(c.rgb, c.hex8), "RGB equals hex " + c.hex);
    assert(tinycolor.equals(c.rgb, c.hsl), "RGB equals HSL " + c.hex);
    assert(tinycolor.equals(c.rgb, c.hsv), "RGB equals HSV " + c.hex);
    assert(tinycolor.equals(c.rgb, c.rgb), "RGB equals RGB " + c.hex);

    assert(tinycolor.equals(c.hex, c.hex), "hex equals hex " + c.hex);
    assert(tinycolor.equals(c.hex, c.hex8), "hex equals hex8 " + c.hex);
    assert(tinycolor.equals(c.hex, c.hsl), "hex equals HSL " + c.hex);
    assert(tinycolor.equals(c.hex, c.hsv), "hex equals HSV " + c.hex);

    assert(tinycolor.equals(c.hsl, c.hsv), "HSL equals HSV " + c.hex);
  }
});

Deno.test("With Ratio", function () {
  assertEquals(
    tinycolor.fromRatio({ r: 1, g: 1, b: 1 }).toHexString(),
    "#ffffff",
    "white"
  );
  assertEquals(
    tinycolor.fromRatio({ r: 1, g: 0, b: 0, a: 0.5 }).toRgbString(),
    "rgba(255, 0, 0, 0.5)",
    "alpha works when ratio is parsed"
  );
  assertEquals(
    tinycolor.fromRatio({ r: 1, g: 0, b: 0, a: 1 }).toRgbString(),
    "rgb(255, 0, 0)",
    "alpha = 1 works when ratio is parsed"
  );
  assertEquals(
    tinycolor.fromRatio({ r: 1, g: 0, b: 0, a: 10 }).toRgbString(),
    "rgb(255, 0, 0)",
    "alpha > 1 works when ratio is parsed"
  );
  assertEquals(
    tinycolor.fromRatio({ r: 1, g: 0, b: 0, a: -1 }).toRgbString(),
    "rgb(255, 0, 0)",
    "alpha < 1 works when ratio is parsed"
  );
});

Deno.test("Without Ratio", function () {
  assertEquals(
    tinycolor({ r: 1, g: 1, b: 1 }).toHexString(),
    "#010101",
    "010101"
  );
  assertEquals(
    tinycolor({ r: 0.1, g: 0.1, b: 0.1 }).toHexString(),
    "#000000",
    "000000"
  );
  assertEquals(tinycolor("rgb .1 .1 .1").toHexString(), "#000000", "000000");
});

Deno.test("RGB Text Parsing", function () {
  assertEquals(
    tinycolor("rgb 255 0 0").toHexString(),
    "#ff0000",
    "spaced input"
  );
  assertEquals(
    tinycolor("rgb(255, 0, 0)").toHexString(),
    "#ff0000",
    "parenthesized input"
  );
  assertEquals(
    tinycolor("rgb (255, 0, 0)").toHexString(),
    "#ff0000",
    "parenthesized spaced input"
  );
  assertEquals(
    tinycolor({ r: 255, g: 0, b: 0 }).toHexString(),
    "#ff0000",
    "object input"
  );
  assertEquals(
    tinycolor({ r: 255, g: 0, b: 0 }).toRgb(),
    {
      r: 255,
      g: 0,
      b: 0,
      a: 1,
    },
    "object input and compare"
  );

  assert(tinycolor.equals({ r: 200, g: 100, b: 0 }, "rgb(200, 100, 0)"));
  assert(tinycolor.equals({ r: 200, g: 100, b: 0 }, "rgb 200 100 0"));
  assert(tinycolor.equals({ r: 200, g: 100, b: 0 }, "rgb 200 100 0"));
  assert(
    tinycolor.equals({ r: 200, g: 100, b: 0, a: 0.4 }, "rgba 200 100 0 .4")
  );
  assert(!tinycolor.equals({ r: 199, g: 100, b: 0 }, "rgba 200 100 0 1"));

  assert(!tinycolor.equals({ r: 199, g: 100, b: 0 }, "rgb(200, 100, 0)"));
  assert(!tinycolor.equals({ r: 199, g: 100, b: 0 }, "rgb 200 100 0"));
  assert(!tinycolor.equals({ r: 199, g: 100, b: 0 }, "rgb 200 100 0"));

  assert(
    tinycolor.equals(tinycolor({ r: 200, g: 100, b: 0 }), "rgb(200, 100, 0)")
  );
  assert(
    tinycolor.equals(tinycolor({ r: 200, g: 100, b: 0 }), "rgb 200 100 0")
  );
  assert(
    tinycolor.equals(tinycolor({ r: 200, g: 100, b: 0 }), "rgb 200 100 0")
  );
});

Deno.test("Percentage RGB Text Parsing", function () {
  assertEquals(
    tinycolor("rgb 100% 0% 0%").toHexString(),
    "#ff0000",
    "spaced input"
  );
  assertEquals(
    tinycolor("rgb(100%, 0%, 0%)").toHexString(),
    "#ff0000",
    "parenthesized input"
  );
  assertEquals(
    tinycolor("rgb (100%, 0%, 0%)").toHexString(),
    "#ff0000",
    "parenthesized spaced input"
  );
  assertEquals(
    tinycolor({ r: "100%", g: "0%", b: "0%" }).toHexString(),
    "#ff0000",
    "object input"
  );
  assertEquals(
    tinycolor({ r: "100%", g: "0%", b: "0%" }).toRgb(),
    {
      r: 255,
      g: 0,
      b: 0,
      a: 1,
    },
    "object input and compare"
  );

  assert(
    tinycolor.equals({ r: "90%", g: "45%", b: "0%" }, "rgb(90%, 45%, 0%)")
  );
  assert(tinycolor.equals({ r: "90%", g: "45%", b: "0%" }, "rgb 90% 45% 0%"));
  assert(tinycolor.equals({ r: "90%", g: "45%", b: "0%" }, "rgb 90% 45% 0%"));
  assert(
    tinycolor.equals(
      { r: "90%", g: "45%", b: "0%", a: 0.4 },
      "rgba 90% 45% 0% .4"
    )
  );
  assert(
    !tinycolor.equals({ r: "89%", g: "45%", b: "0%" }, "rgba 90% 45% 0% 1")
  );

  assert(
    !tinycolor.equals({ r: "89%", g: "45%", b: "0%" }, "rgb(90%, 45%, 0%)")
  );
  assert(!tinycolor.equals({ r: "89%", g: "45%", b: "0%" }, "rgb 90% 45% 0%"));
  assert(!tinycolor.equals({ r: "89%", g: "45%", b: "0%" }, "rgb 90% 45% 0%"));

  assert(
    tinycolor.equals(
      tinycolor({ r: "90%", g: "45%", b: "0%" }),
      "rgb(90%, 45%, 0%)"
    )
  );
  assert(
    tinycolor.equals(
      tinycolor({ r: "90%", g: "45%", b: "0%" }),
      "rgb 90% 45% 0%"
    )
  );
  assert(
    tinycolor.equals(
      tinycolor({ r: "90%", g: "45%", b: "0%" }),
      "rgb 90% 45% 0%"
    )
  );
});

Deno.test("HSL parsing", function () {
  assertEquals(
    tinycolor({ h: 251, s: 100, l: 0.38 }).toHexString(),
    "#2400c2",
    "to hex"
  );
  assertEquals(
    tinycolor({ h: 251, s: 100, l: 0.38 }).toRgbString(),
    "rgb(36, 0, 194)",
    "to rgb"
  );
  assertEquals(
    tinycolor({ h: 251, s: 100, l: 0.38 }).toHslString(),
    "hsl(251, 100%, 38%)",
    "to hsl"
  );
  assertEquals(
    tinycolor({ h: 251, s: 100, l: 0.38, a: 0.5 }).toHslString(),
    "hsla(251, 100%, 38%, 0.5)",
    "to hsla"
  );
  assertEquals(
    tinycolor("hsl(251, 100, 38)").toHexString(),
    "#2400c2",
    "to hex"
  );
  assertEquals(
    tinycolor("hsl(251, 100%, 38%)").toRgbString(),
    "rgb(36, 0, 194)",
    "to rgb"
  );
  assertEquals(
    tinycolor("hsl(251, 100%, 38%)").toHslString(),
    "hsl(251, 100%, 38%)",
    "to hsl"
  );
  assertEquals(
    tinycolor("hsl 100 20 10").toHslString(),
    "hsl(100, 20%, 10%)",
    "problematic hsl"
  );
});

Deno.test("Hex Parsing", function () {
  assertEquals(tinycolor("rgb 255 0 0").toHexString(), "#ff0000");
  assertEquals(tinycolor("rgb 255 0 0").toHexString(true), "#f00");

  assertEquals(tinycolor("rgba 255 0 0 0.5").toHex8String(), "#ff000080");
  assertEquals(tinycolor("rgba 255 0 0 0").toHex8String(), "#ff000000");
  assertEquals(tinycolor("rgba 255 0 0 1").toHex8String(), "#ff0000ff");
  assertEquals(tinycolor("rgba 255 0 0 1").toHex8String(true), "#f00f");

  assertEquals(tinycolor("rgb 255 0 0").toHex(), "ff0000");
  assertEquals(tinycolor("rgb 255 0 0").toHex(true), "f00");
  assertEquals(tinycolor("rgba 255 0 0 0.5").toHex8(), "ff000080");
});

Deno.test("HSV Parsing", function () {
  assertEquals(
    tinycolor("hsv 251.1 0.887 .918").toHsvString(),
    "hsv(251, 89%, 92%)"
  );
  assertEquals(
    tinycolor("hsv 251.1 0.887 0.918").toHsvString(),
    "hsv(251, 89%, 92%)"
  );
  assertEquals(
    tinycolor("hsva 251.1 0.887 0.918 0.5").toHsvString(),
    "hsva(251, 89%, 92%, 0.5)"
  );
});

Deno.test("Invalid Parsing", function () {
  var invalidColor = tinycolor("this is not a color");
  assertEquals(invalidColor.toHexString(), "#000000");
  assertEquals(false, invalidColor.isValid());

  invalidColor = tinycolor("#red");
  assertEquals(invalidColor.toHexString(), "#000000");
  assertEquals(false, invalidColor.isValid());

  invalidColor = tinycolor("  #red");
  assertEquals(invalidColor.toHexString(), "#000000");
  assertEquals(false, invalidColor.isValid());

  invalidColor = tinycolor("##123456");
  assertEquals(invalidColor.toHexString(), "#000000");
  assertEquals(false, invalidColor.isValid());

  invalidColor = tinycolor("  ##123456");
  assertEquals(invalidColor.toHexString(), "#000000");
  assertEquals(false, invalidColor.isValid());

  invalidColor = tinycolor({ r: "invalid", g: "invalid", b: "invalid" });
  assertEquals(invalidColor.toHexString(), "#000000");
  assertEquals(false, invalidColor.isValid());

  invalidColor = tinycolor({ h: "invalid", s: "invalid", l: "invalid" });
  assertEquals(invalidColor.toHexString(), "#000000");
  assertEquals(false, invalidColor.isValid());

  invalidColor = tinycolor({ h: "invalid", s: "invalid", v: "invalid" });
  assertEquals(invalidColor.toHexString(), "#000000");
  assertEquals(false, invalidColor.isValid());
});

Deno.test("Named colors", function () {
  assertEquals(tinycolor("aliceblue").toHex(), "f0f8ff");
  assertEquals(tinycolor("antiquewhite").toHex(), "faebd7");
  assertEquals(tinycolor("aqua").toHex(), "00ffff");
  assertEquals(tinycolor("aquamarine").toHex(), "7fffd4");
  assertEquals(tinycolor("azure").toHex(), "f0ffff");
  assertEquals(tinycolor("beige").toHex(), "f5f5dc");
  assertEquals(tinycolor("bisque").toHex(), "ffe4c4");
  assertEquals(tinycolor("black").toHex(), "000000");
  assertEquals(tinycolor("blanchedalmond").toHex(), "ffebcd");
  assertEquals(tinycolor("blue").toHex(), "0000ff");
  assertEquals(tinycolor("blueviolet").toHex(), "8a2be2");
  assertEquals(tinycolor("brown").toHex(), "a52a2a");
  assertEquals(tinycolor("burlywood").toHex(), "deb887");
  assertEquals(tinycolor("cadetblue").toHex(), "5f9ea0");
  assertEquals(tinycolor("chartreuse").toHex(), "7fff00");
  assertEquals(tinycolor("chocolate").toHex(), "d2691e");
  assertEquals(tinycolor("coral").toHex(), "ff7f50");
  assertEquals(tinycolor("cornflowerblue").toHex(), "6495ed");
  assertEquals(tinycolor("cornsilk").toHex(), "fff8dc");
  assertEquals(tinycolor("crimson").toHex(), "dc143c");
  assertEquals(tinycolor("cyan").toHex(), "00ffff");
  assertEquals(tinycolor("darkblue").toHex(), "00008b");
  assertEquals(tinycolor("darkcyan").toHex(), "008b8b");
  assertEquals(tinycolor("darkgoldenrod").toHex(), "b8860b");
  assertEquals(tinycolor("darkgray").toHex(), "a9a9a9");
  assertEquals(tinycolor("darkgreen").toHex(), "006400");
  assertEquals(tinycolor("darkkhaki").toHex(), "bdb76b");
  assertEquals(tinycolor("darkmagenta").toHex(), "8b008b");
  assertEquals(tinycolor("darkolivegreen").toHex(), "556b2f");
  assertEquals(tinycolor("darkorange").toHex(), "ff8c00");
  assertEquals(tinycolor("darkorchid").toHex(), "9932cc");
  assertEquals(tinycolor("darkred").toHex(), "8b0000");
  assertEquals(tinycolor("darksalmon").toHex(), "e9967a");
  assertEquals(tinycolor("darkseagreen").toHex(), "8fbc8f");
  assertEquals(tinycolor("darkslateblue").toHex(), "483d8b");
  assertEquals(tinycolor("darkslategray").toHex(), "2f4f4f");
  assertEquals(tinycolor("darkturquoise").toHex(), "00ced1");
  assertEquals(tinycolor("darkviolet").toHex(), "9400d3");
  assertEquals(tinycolor("deeppink").toHex(), "ff1493");
  assertEquals(tinycolor("deepskyblue").toHex(), "00bfff");
  assertEquals(tinycolor("dimgray").toHex(), "696969");
  assertEquals(tinycolor("dodgerblue").toHex(), "1e90ff");
  assertEquals(tinycolor("firebrick").toHex(), "b22222");
  assertEquals(tinycolor("floralwhite").toHex(), "fffaf0");
  assertEquals(tinycolor("forestgreen").toHex(), "228b22");
  assertEquals(tinycolor("fuchsia").toHex(), "ff00ff");
  assertEquals(tinycolor("gainsboro").toHex(), "dcdcdc");
  assertEquals(tinycolor("ghostwhite").toHex(), "f8f8ff");
  assertEquals(tinycolor("gold").toHex(), "ffd700");
  assertEquals(tinycolor("goldenrod").toHex(), "daa520");
  assertEquals(tinycolor("gray").toHex(), "808080");
  assertEquals(tinycolor("grey").toHex(), "808080");
  assertEquals(tinycolor("green").toHex(), "008000");
  assertEquals(tinycolor("greenyellow").toHex(), "adff2f");
  assertEquals(tinycolor("honeydew").toHex(), "f0fff0");
  assertEquals(tinycolor("hotpink").toHex(), "ff69b4");
  assertEquals(tinycolor("indianred ").toHex(), "cd5c5c");
  assertEquals(tinycolor("indigo ").toHex(), "4b0082");
  assertEquals(tinycolor("ivory").toHex(), "fffff0");
  assertEquals(tinycolor("khaki").toHex(), "f0e68c");
  assertEquals(tinycolor("lavender").toHex(), "e6e6fa");
  assertEquals(tinycolor("lavenderblush").toHex(), "fff0f5");
  assertEquals(tinycolor("lawngreen").toHex(), "7cfc00");
  assertEquals(tinycolor("lemonchiffon").toHex(), "fffacd");
  assertEquals(tinycolor("lightblue").toHex(), "add8e6");
  assertEquals(tinycolor("lightcoral").toHex(), "f08080");
  assertEquals(tinycolor("lightcyan").toHex(), "e0ffff");
  assertEquals(tinycolor("lightgoldenrodyellow").toHex(), "fafad2");
  assertEquals(tinycolor("lightgrey").toHex(), "d3d3d3");
  assertEquals(tinycolor("lightgreen").toHex(), "90ee90");
  assertEquals(tinycolor("lightpink").toHex(), "ffb6c1");
  assertEquals(tinycolor("lightsalmon").toHex(), "ffa07a");
  assertEquals(tinycolor("lightseagreen").toHex(), "20b2aa");
  assertEquals(tinycolor("lightskyblue").toHex(), "87cefa");
  assertEquals(tinycolor("lightslategray").toHex(), "778899");
  assertEquals(tinycolor("lightsteelblue").toHex(), "b0c4de");
  assertEquals(tinycolor("lightyellow").toHex(), "ffffe0");
  assertEquals(tinycolor("lime").toHex(), "00ff00");
  assertEquals(tinycolor("limegreen").toHex(), "32cd32");
  assertEquals(tinycolor("linen").toHex(), "faf0e6");
  assertEquals(tinycolor("magenta").toHex(), "ff00ff");
  assertEquals(tinycolor("maroon").toHex(), "800000");
  assertEquals(tinycolor("mediumaquamarine").toHex(), "66cdaa");
  assertEquals(tinycolor("mediumblue").toHex(), "0000cd");
  assertEquals(tinycolor("mediumorchid").toHex(), "ba55d3");
  assertEquals(tinycolor("mediumpurple").toHex(), "9370db");
  assertEquals(tinycolor("mediumseagreen").toHex(), "3cb371");
  assertEquals(tinycolor("mediumslateblue").toHex(), "7b68ee");
  assertEquals(tinycolor("mediumspringgreen").toHex(), "00fa9a");
  assertEquals(tinycolor("mediumturquoise").toHex(), "48d1cc");
  assertEquals(tinycolor("mediumvioletred").toHex(), "c71585");
  assertEquals(tinycolor("midnightblue").toHex(), "191970");
  assertEquals(tinycolor("mintcream").toHex(), "f5fffa");
  assertEquals(tinycolor("mistyrose").toHex(), "ffe4e1");
  assertEquals(tinycolor("moccasin").toHex(), "ffe4b5");
  assertEquals(tinycolor("navajowhite").toHex(), "ffdead");
  assertEquals(tinycolor("navy").toHex(), "000080");
  assertEquals(tinycolor("oldlace").toHex(), "fdf5e6");
  assertEquals(tinycolor("olive").toHex(), "808000");
  assertEquals(tinycolor("olivedrab").toHex(), "6b8e23");
  assertEquals(tinycolor("orange").toHex(), "ffa500");
  assertEquals(tinycolor("orangered").toHex(), "ff4500");
  assertEquals(tinycolor("orchid").toHex(), "da70d6");
  assertEquals(tinycolor("palegoldenrod").toHex(), "eee8aa");
  assertEquals(tinycolor("palegreen").toHex(), "98fb98");
  assertEquals(tinycolor("paleturquoise").toHex(), "afeeee");
  assertEquals(tinycolor("palevioletred").toHex(), "db7093");
  assertEquals(tinycolor("papayawhip").toHex(), "ffefd5");
  assertEquals(tinycolor("peachpuff").toHex(), "ffdab9");
  assertEquals(tinycolor("peru").toHex(), "cd853f");
  assertEquals(tinycolor("pink").toHex(), "ffc0cb");
  assertEquals(tinycolor("plum").toHex(), "dda0dd");
  assertEquals(tinycolor("powderblue").toHex(), "b0e0e6");
  assertEquals(tinycolor("purple").toHex(), "800080");
  assertEquals(tinycolor("rebeccapurple").toHex(), "663399");
  assertEquals(tinycolor("red").toHex(), "ff0000");
  assertEquals(tinycolor("rosybrown").toHex(), "bc8f8f");
  assertEquals(tinycolor("royalblue").toHex(), "4169e1");
  assertEquals(tinycolor("saddlebrown").toHex(), "8b4513");
  assertEquals(tinycolor("salmon").toHex(), "fa8072");
  assertEquals(tinycolor("sandybrown").toHex(), "f4a460");
  assertEquals(tinycolor("seagreen").toHex(), "2e8b57");
  assertEquals(tinycolor("seashell").toHex(), "fff5ee");
  assertEquals(tinycolor("sienna").toHex(), "a0522d");
  assertEquals(tinycolor("silver").toHex(), "c0c0c0");
  assertEquals(tinycolor("skyblue").toHex(), "87ceeb");
  assertEquals(tinycolor("slateblue").toHex(), "6a5acd");
  assertEquals(tinycolor("slategray").toHex(), "708090");
  assertEquals(tinycolor("snow").toHex(), "fffafa");
  assertEquals(tinycolor("springgreen").toHex(), "00ff7f");
  assertEquals(tinycolor("steelblue").toHex(), "4682b4");
  assertEquals(tinycolor("tan").toHex(), "d2b48c");
  assertEquals(tinycolor("teal").toHex(), "008080");
  assertEquals(tinycolor("thistle").toHex(), "d8bfd8");
  assertEquals(tinycolor("tomato").toHex(), "ff6347");
  assertEquals(tinycolor("turquoise").toHex(), "40e0d0");
  assertEquals(tinycolor("violet").toHex(), "ee82ee");
  assertEquals(tinycolor("wheat").toHex(), "f5deb3");
  assertEquals(tinycolor("white").toHex(), "ffffff");
  assertEquals(tinycolor("whitesmoke").toHex(), "f5f5f5");
  assertEquals(tinycolor("yellow").toHex(), "ffff00");
  assertEquals(tinycolor("yellowgreen").toHex(), "9acd32");

  assertEquals(tinycolor("#f00").toName(), "red");
  assertEquals(tinycolor("#fa0a0a").toName(), false);
});

Deno.test("Invalid alpha should normalize to 1", function () {
  assertEquals(
    tinycolor({ r: 255, g: 20, b: 10, a: -1 }).toRgbString(),
    "rgb(255, 20, 10)",
    "Negative value"
  );
  assertEquals(
    tinycolor({ r: 255, g: 20, b: 10, a: -0 }).toRgbString(),
    "rgba(255, 20, 10, 0)",
    "Negative 0"
  );
  assertEquals(
    tinycolor({ r: 255, g: 20, b: 10, a: 0 }).toRgbString(),
    "rgba(255, 20, 10, 0)",
    "0"
  );
  assertEquals(
    tinycolor({ r: 255, g: 20, b: 10, a: 0.5 }).toRgbString(),
    "rgba(255, 20, 10, 0.5)",
    ".5"
  );
  assertEquals(
    tinycolor({ r: 255, g: 20, b: 10, a: 1 }).toRgbString(),
    "rgb(255, 20, 10)",
    "1"
  );
  assertEquals(
    tinycolor({ r: 255, g: 20, b: 10, a: 100 }).toRgbString(),
    "rgb(255, 20, 10)",
    "Greater than 1"
  );
  assertEquals(
    tinycolor({ r: 255, g: 20, b: 10, a: "asdfasd" }).toRgbString(),
    "rgb(255, 20, 10)",
    "Non Numeric"
  );

  assertEquals(
    tinycolor("#fff").toRgbString(),
    "rgb(255, 255, 255)",
    "Hex should be 1"
  );
  assertEquals(
    tinycolor("rgba 255 0 0 100").toRgbString(),
    "rgb(255, 0, 0)",
    "Greater than 1 in string parsing"
  );
});

Deno.test("toString() with alpha set", function () {
  var redNamed = tinycolor.fromRatio(
    { r: 255, g: 0, b: 0, a: 0.6 },
    {
      format: "name",
    }
  );
  var transparentNamed = tinycolor.fromRatio(
    { r: 255, g: 0, b: 0, a: 0 },
    {
      format: "name",
    }
  );
  var redHex = tinycolor.fromRatio(
    { r: 255, g: 0, b: 0, a: 0.4 },
    {
      format: "hex",
    }
  );

  assertEquals(redNamed.getFormat(), "name", "getFormat() is correct");
  assertEquals(redHex.getFormat(), "hex", "getFormat() is correct");

  assertEquals(
    redNamed.toString(),
    "rgba(255, 0, 0, 0.6)",
    "Names should default to rgba if alpha is < 1"
  );
  assertEquals(
    redHex.toString(),
    "rgba(255, 0, 0, 0.4)",
    "Hex should default to rgba if alpha is < 1"
  );

  assertEquals(
    redNamed.toString("hex"),
    "#ff0000",
    "Names should not be returned as rgba if format is specified"
  );
  assertEquals(
    redNamed.toString("hex6"),
    "#ff0000",
    "Names should not be returned as rgba if format is specified"
  );
  assertEquals(
    redNamed.toString("hex3"),
    "#f00",
    "Names should not be returned as rgba if format is specified"
  );
  assertEquals(
    redNamed.toString("hex8"),
    "#ff000099",
    "Names should not be returned as rgba if format is specified"
  );
  assertEquals(
    redNamed.toString("hex4"),
    "#f009",
    "Names should not be returned as rgba if format is specified"
  );
  assertEquals(
    redNamed.toString("name"),
    "#ff0000",
    "Semi transparent names should return hex in toString() if name format is specified"
  );

  assertEquals(
    redNamed.toName(),
    false,
    "Semi transparent names should be false in toName()"
  );

  assertEquals(
    redHex.toString(),
    "rgba(255, 0, 0, 0.4)",
    "Hex should default to rgba if alpha is < 1"
  );
  assertEquals(
    transparentNamed.toString(),
    "transparent",
    "Named color should equal transparent if alpha == 0"
  );

  redHex.setAlpha(0);
  assertEquals(
    redHex.toString(),
    "rgba(255, 0, 0, 0)",
    "Hex should default to rgba if alpha is = 0"
  );
});

Deno.test("setting alpha", function () {
  var hexSetter = tinycolor("rgba(255, 0, 0, 1)");
  assertEquals(hexSetter.getAlpha(), 1, "Alpha should start as 1");
  var returnedFromSetAlpha = hexSetter.setAlpha(0.9);
  assertEquals(
    returnedFromSetAlpha,
    hexSetter,
    "setAlpha return value should be the color."
  );
  assertEquals(hexSetter.getAlpha(), 0.9, "setAlpha should change alpha value");
  hexSetter.setAlpha(0.5);
  assertEquals(hexSetter.getAlpha(), 0.5, "setAlpha should change alpha value");
  hexSetter.setAlpha(0);
  assertEquals(hexSetter.getAlpha(), 0, "setAlpha should change alpha value");
  hexSetter.setAlpha(-1);
  assertEquals(
    hexSetter.getAlpha(),
    1,
    "setAlpha with value < 0 should be bound to 1"
  );
  hexSetter.setAlpha(2);
  assertEquals(
    hexSetter.getAlpha(),
    1,
    "setAlpha with value > 1 should be bound to 1"
  );
  hexSetter.setAlpha();
  assertEquals(
    hexSetter.getAlpha(),
    1,
    "setAlpha with invalid value should be bound to 1"
  );
  hexSetter.setAlpha(null);
  assertEquals(
    hexSetter.getAlpha(),
    1,
    "setAlpha with invalid value should be bound to 1"
  );
  hexSetter.setAlpha("test");
  assertEquals(
    hexSetter.getAlpha(),
    1,
    "setAlpha with invalid value should be bound to 1"
  );
});

Deno.test("Alpha = 0 should act differently on toName()", function () {
  assertEquals(
    tinycolor({ r: 255, g: 20, b: 10, a: 0 }).toName(),
    "transparent",
    "0"
  );
  assertEquals(
    tinycolor("transparent").toString(),
    "transparent",
    "toString when passed"
  );
  assertEquals(tinycolor("transparent").toHex(), "000000", "toHex");
});

Deno.test("getBrightness", function () {
  assertEquals(tinycolor("#000").getBrightness(), 0, "returns 0 for #000");
  assertEquals(tinycolor("#fff").getBrightness(), 255, "returns 255 for #fff");
});

Deno.test("getLuminance", function () {
  assertEquals(tinycolor("#000").getLuminance(), 0, "returns 0 for #000");
  assertEquals(tinycolor("#fff").getLuminance(), 1, "returns 1 for #fff");
});

Deno.test("isDark returns true/false for dark/light colors", function () {
  assertEquals(tinycolor("#000").isDark(), true, "#000 is dark");
  assertEquals(tinycolor("#111").isDark(), true, "#111 is dark");
  assertEquals(tinycolor("#222").isDark(), true, "#222 is dark");
  assertEquals(tinycolor("#333").isDark(), true, "#333 is dark");
  assertEquals(tinycolor("#444").isDark(), true, "#444 is dark");
  assertEquals(tinycolor("#555").isDark(), true, "#555 is dark");
  assertEquals(tinycolor("#666").isDark(), true, "#666 is dark");
  assertEquals(tinycolor("#777").isDark(), true, "#777 is dark");
  assertEquals(tinycolor("#888").isDark(), false, "#888 is not dark");
  assertEquals(tinycolor("#999").isDark(), false, "#999 is not dark");
  assertEquals(tinycolor("#aaa").isDark(), false, "#aaa is not dark");
  assertEquals(tinycolor("#bbb").isDark(), false, "#bbb is not dark");
  assertEquals(tinycolor("#ccc").isDark(), false, "#ccc is not dark");
  assertEquals(tinycolor("#ddd").isDark(), false, "#ddd is not dark");
  assertEquals(tinycolor("#eee").isDark(), false, "#eee is not dark");
  assertEquals(tinycolor("#fff").isDark(), false, "#fff is not dark");
});

Deno.test("isLight returns true/false for light/dark colors", function () {
  assertEquals(tinycolor("#000").isLight(), false, "#000 is not light");
  assertEquals(tinycolor("#111").isLight(), false, "#111 is not light");
  assertEquals(tinycolor("#222").isLight(), false, "#222 is not light");
  assertEquals(tinycolor("#333").isLight(), false, "#333 is not light");
  assertEquals(tinycolor("#444").isLight(), false, "#444 is not light");
  assertEquals(tinycolor("#555").isLight(), false, "#555 is not light");
  assertEquals(tinycolor("#666").isLight(), false, "#666 is not light");
  assertEquals(tinycolor("#777").isLight(), false, "#777 is not light");
  assertEquals(tinycolor("#888").isLight(), true, "#888 is light");
  assertEquals(tinycolor("#999").isLight(), true, "#999 is light");
  assertEquals(tinycolor("#aaa").isLight(), true, "#aaa is light");
  assertEquals(tinycolor("#bbb").isLight(), true, "#bbb is light");
  assertEquals(tinycolor("#ccc").isLight(), true, "#ccc is light");
  assertEquals(tinycolor("#ddd").isLight(), true, "#ddd is light");
  assertEquals(tinycolor("#eee").isLight(), true, "#eee is light");
  assertEquals(tinycolor("#fff").isLight(), true, "#fff is light");
});

Deno.test("HSL Object", function () {
  for (var i = 0; i < conversions.length; i++) {
    var c = conversions[i];
    var tiny = tinycolor(c.hex);
    assertEquals(
      tiny.toHexString(),
      tinycolor(tiny.toHsl()).toHexString(),
      "HSL Object"
    );
  }
});

Deno.test("HSL String", function () {
  for (var i = 0; i < conversions.length; i++) {
    var c = conversions[i];
    var tiny = tinycolor(c.hex);
    var input = tiny.toRgb();
    var output = tinycolor(tiny.toHslString()).toRgb();
    var maxDiff = 2;

    assertEquals(
      Math.abs(input.r - output.r) <= maxDiff,
      true,
      "toHslString red value difference <= " + maxDiff
    );
    assertEquals(
      Math.abs(input.g - output.g) <= maxDiff,
      true,
      "toHslString green value difference <= " + maxDiff
    );
    assertEquals(
      Math.abs(input.b - output.b) <= maxDiff,
      true,
      "toHslString blue value difference <= " + maxDiff
    );
  }
});

Deno.test("HSV String", function () {
  for (var i = 0; i < conversions.length; i++) {
    var c = conversions[i];
    var tiny = tinycolor(c.hex);
    var input = tiny.toRgb();
    var output = tinycolor(tiny.toHsvString()).toRgb();
    var maxDiff = 2;

    assertEquals(
      Math.abs(input.r - output.r) <= maxDiff,
      true,
      "toHsvString red value difference <= " + maxDiff
    );
    assertEquals(
      Math.abs(input.g - output.g) <= maxDiff,
      true,
      "toHsvString green value difference <= " + maxDiff
    );
    assertEquals(
      Math.abs(input.b - output.b) <= maxDiff,
      true,
      "toHsvString blue value difference <= " + maxDiff
    );
  }
});

Deno.test("HSV Object", function () {
  for (var i = 0; i < conversions.length; i++) {
    var c = conversions[i];
    var tiny = tinycolor(c.hex);
    assertEquals(
      tiny.toHexString(),
      tinycolor(tiny.toHsv()).toHexString(),
      "HSV Object"
    );
  }
});

Deno.test("RGB Object", function () {
  for (var i = 0; i < conversions.length; i++) {
    var c = conversions[i];
    var tiny = tinycolor(c.hex);
    assertEquals(
      tiny.toHexString(),
      tinycolor(tiny.toRgb()).toHexString(),
      "RGB Object"
    );
  }
});

Deno.test("RGB String", function () {
  for (var i = 0; i < conversions.length; i++) {
    var c = conversions[i];
    var tiny = tinycolor(c.hex);
    assertEquals(
      tiny.toHexString(),
      tinycolor(tiny.toRgbString()).toHexString(),
      "RGB String"
    );
  }
});

Deno.test("PRGB Object", function () {
  for (var i = 0; i < conversions.length; i++) {
    var c = conversions[i];
    var tiny = tinycolor(c.hex);
    var input = tiny.toRgb();
    var output = tinycolor(tiny.toPercentageRgb()).toRgb();
    var maxDiff = 2;

    assertEquals(
      Math.abs(input.r - output.r) <= maxDiff,
      true,
      "Red value difference <= " + maxDiff
    );
    assertEquals(
      Math.abs(input.g - output.g) <= maxDiff,
      true,
      "Green value difference <= " + maxDiff
    );
    assertEquals(
      Math.abs(input.b - output.b) <= maxDiff,
      true,
      "Blue value difference <= " + maxDiff
    );
  }
});

Deno.test("PRGB String", function () {
  for (var i = 0; i < conversions.length; i++) {
    var c = conversions[i];
    var tiny = tinycolor(c.hex);
    var input = tiny.toRgb();
    var output = tinycolor(tiny.toPercentageRgbString()).toRgb();
    var maxDiff = 2;

    assertEquals(
      Math.abs(input.r - output.r) <= maxDiff,
      true,
      "Red value difference <= " + maxDiff
    );
    assertEquals(
      Math.abs(input.g - output.g) <= maxDiff,
      true,
      "Green value difference <= " + maxDiff
    );
    assertEquals(
      Math.abs(input.b - output.b) <= maxDiff,
      true,
      "Blue value difference <= " + maxDiff
    );
  }
});

Deno.test("Object", function () {
  for (var i = 0; i < conversions.length; i++) {
    var c = conversions[i];
    var tiny = tinycolor(c.hex);
    assertEquals(tiny.toHexString(), tinycolor(tiny).toHexString(), "Object");
  }
});

Deno.test("Color equality", function () {
  assert(tinycolor.equals("#ff0000", "#ff0000"), "Same hex");
  assert(tinycolor.equals("#ff0000", "rgb(255, 0, 0)"), "Same alphas");
  assert(
    !tinycolor.equals("#ff0000", "rgba(255, 0, 0, .1)"),
    "Different alphas"
  );
  assert(tinycolor.equals("#ff000066", "rgba(255, 0, 0, .4)"), "Same alphas");
  assert(tinycolor.equals("#f009", "rgba(255, 0, 0, .6)"), "Same alphas");
  assert(tinycolor.equals("#336699CC", "369C"), "Same hex");
  assert(tinycolor.equals("ff0000", "#ff0000"), "Same hex");
  assert(tinycolor.equals("#f00", "#ff0000"), "Same hex");
  assert(tinycolor.equals("#f00", "#ff0000"), "Same hex");
  assert(tinycolor.equals("f00", "#ff0000"), "Same hex");
  assertEquals(tinycolor("010101").toHexString(), "#010101");
  assert(!tinycolor.equals("#ff0000", "#00ff00"), "Different hex");
  assert(
    tinycolor.equals("#ff8000", "rgb(100%, 50%, 0%)"),
    "Percentage bounds checking"
  );
});

Deno.test("isReadable", function () {
  // "#ff0088", "#8822aa" (values used in old WCAG1 tests)
  assert(
    tinycolor.isReadable("#000000", "#ffffff", { level: "AA", size: "small" }),
    "white/black is readable"
  );
  assert(
    !tinycolor.isReadable("#ff0088", "#5c1a72", {}),
    "not readable - empty wcag2 object"
  );
  assert(
    !tinycolor.isReadable("#ff0088", "#8822aa", { level: "AA", size: "small" }),
    "not readable - AA small"
  );
  assert(
    !tinycolor.isReadable("#ff0088", "#8822aa", { level: "AA", size: "large" }),
    "not  readable - AA large"
  );
  assert(
    !tinycolor.isReadable("#ff0088", "#8822aa", {
      level: "AAA",
      size: "small",
    }),
    "not readable - AAA small"
  );
  assert(
    !tinycolor.isReadable("#ff0088", "#8822aa", {
      level: "AAA",
      size: "large",
    }),
    "not readable - AAA large"
  );

  // values derived from and validated using the calculators at http://www.dasplankton.de/ContrastA/
  // and http://webaim.org/resources/contrastchecker/

  // "#ff0088", "#5c1a72": contrast ratio 3.04
  assert(
    !tinycolor.isReadable("#ff0088", "#5c1a72", { level: "AA", size: "small" }),
    "not readable - AA small"
  );
  assert(
    tinycolor.isReadable("#ff0088", "#5c1a72", { level: "AA", size: "large" }),
    "readable - AA large"
  );
  assert(
    !tinycolor.isReadable("#ff0088", "#5c1a72", {
      level: "AAA",
      size: "small",
    }),
    "not readable - AAA small"
  );
  assert(
    !tinycolor.isReadable("#ff0088", "#5c1a72", {
      level: "AAA",
      size: "large",
    }),
    "not readable - AAA large"
  );

  // "#ff0088", "#2e0c3a": contrast ratio 4.56
  assert(
    tinycolor.isReadable("#ff0088", "#2e0c3a", { level: "AA", size: "small" }),
    "readable - AA small"
  );
  assert(
    tinycolor.isReadable("#ff0088", "#2e0c3a", { level: "AA", size: "large" }),
    "readable - AA large"
  );
  assert(
    !tinycolor.isReadable("#ff0088", "#2e0c3a", {
      level: "AAA",
      size: "small",
    }),
    "not readable - AAA small"
  );
  assert(
    tinycolor.isReadable("#ff0088", "#2e0c3a", { level: "AAA", size: "large" }),
    "readable - AAA large"
  );

  // "#db91b8", "#2e0c3a":  contrast ratio 7.12
  assert(
    tinycolor.isReadable("#db91b8", "#2e0c3a", { level: "AA", size: "small" }),
    "readable - AA small"
  );
  assert(
    tinycolor.isReadable("#db91b8", "#2e0c3a", { level: "AA", size: "large" }),
    "readable - AA large"
  );
  assert(
    tinycolor.isReadable("#db91b8", "#2e0c3a", { level: "AAA", size: "small" }),
    "readable - AAA small"
  );
  assert(
    tinycolor.isReadable("#db91b8", "#2e0c3a", { level: "AAA", size: "large" }),
    "readable - AAA large"
  );
});

Deno.test("readability", function () {
  // check return values from readability function. See isReadable above for standards tests.
  assertEquals(
    tinycolor.readability("#000", "#000"),
    1,
    "Readability function test 0"
  );
  assertEquals(
    tinycolor.readability("#000", "#111"),
    1.1121078324840545,
    "Readability function test 1"
  );
  assertEquals(
    tinycolor.readability("#000", "#fff"),
    21,
    "Readability function test 2"
  );
});

Deno.test("mostReadable", function () {
  assertEquals(
    tinycolor
      .mostReadable("#000", ["#111", "#222", { wcag2: {} }])
      .toHexString(),
    "#222222",
    "readable color present"
  );
  assertEquals(
    tinycolor
      .mostReadable("#f00", ["#d00", "#0d0"], { wcag2: {} })
      .toHexString(),
    "#00dd00",
    "readable color present"
  );
  assertEquals(
    tinycolor
      .mostReadable("#fff", ["#fff", "#fff"], { wcag2: {} })
      .toHexString(),
    "#ffffff",
    "no different color in list"
  );
  //includeFallbackColors
  assertEquals(
    tinycolor
      .mostReadable("#fff", ["#fff", "#fff"], {
        includeFallbackColors: true,
      })
      .toHexString(),
    "#000000",
    "no different color in list"
  );
  assertEquals(
    tinycolor
      .mostReadable("#123", ["#124", "#125"], {
        includeFallbackColors: false,
      })
      .toHexString(),
    "#112255",
    "no readable color in list"
  );
  assertEquals(
    tinycolor
      .mostReadable("#123", ["#000", "#fff"], {
        includeFallbackColors: false,
      })
      .toHexString(),
    "#ffffff",
    "verify assumption"
  );
  assertEquals(
    tinycolor
      .mostReadable("#123", ["#124", "#125"], {
        includeFallbackColors: true,
      })
      .toHexString(),
    "#ffffff",
    "no readable color in list"
  );

  assertEquals(
    tinycolor
      .mostReadable("#ff0088", ["#000", "#fff"], {
        includeFallbackColors: false,
      })
      .toHexString(),
    "#000000",
    "verify assumption"
  );
  assertEquals(
    tinycolor
      .mostReadable("#ff0088", ["#2e0c3a"], {
        includeFallbackColors: true,
        level: "AAA",
        size: "large",
      })
      .toHexString(),
    "#2e0c3a",
    "readable color present"
  );
  assertEquals(
    tinycolor
      .mostReadable("#ff0088", ["#2e0c3a"], {
        includeFallbackColors: true,
        level: "AAA",
        size: "small",
      })
      .toHexString(),
    "#000000",
    "no readable color in list"
  );

  assertEquals(
    tinycolor
      .mostReadable("#371b2c", ["#000", "#fff"], {
        includeFallbackColors: false,
      })
      .toHexString(),
    "#ffffff",
    "verify assumption"
  );
  assertEquals(
    tinycolor
      .mostReadable("#371b2c", ["#a9acb6"], {
        includeFallbackColors: true,
        level: "AAA",
        size: "large",
      })
      .toHexString(),
    "#a9acb6",
    "readable color present"
  );
  assertEquals(
    tinycolor
      .mostReadable("#371b2c", ["#a9acb6"], {
        includeFallbackColors: true,
        level: "AAA",
        size: "small",
      })
      .toHexString(),
    "#ffffff",
    "no readable color in list"
  );
});

Deno.test("Filters", function () {
  assertEquals(
    tinycolor("red").toFilter(),
    "progid:DXImageTransform.Microsoft.gradient(startColorstr=#ffff0000,endColorstr=#ffff0000)"
  );
  assertEquals(
    tinycolor("red").toFilter("blue"),
    "progid:DXImageTransform.Microsoft.gradient(startColorstr=#ffff0000,endColorstr=#ff0000ff)"
  );

  assertEquals(
    tinycolor("transparent").toFilter(),
    "progid:DXImageTransform.Microsoft.gradient(startColorstr=#00000000,endColorstr=#00000000)"
  );
  assertEquals(
    tinycolor("transparent").toFilter("red"),
    "progid:DXImageTransform.Microsoft.gradient